@Tutorial(time: 20) {
    @Intro(title: "Migrating a test from XCTest") {
        Migrate an existing test method or test class written using XCTest.
        
        @Image(source: migrate-from-xctest.png, alt: "Illustration on migration from XCTest to Swift Testing")
    }
    
    @Section(title: "Migrate an existing method or test class written using XCTest") {
        @ContentAndMedia {
            
            @Image(source: swift-testing-hero-dark.png, alt: "Swift Testing illustration.")

            The testing library provides much of the same functionality of XCTest, but uses its own syntax to declare test functions and types. Here, you’ll learn how to convert XCTest-based content to use the testing library instead.
            
            The following table includes a list of the various XCTAssert() functions and their equivalents in the new Testing library:
            
            XCTest       | Swift Testing                          
            ------------ | ------------------------------------- 
            |`XCTAssert(x), XCTAssertTrue(x)`       | `#expect(x) |
            `XCTAssertFalse(x)`     | `#expect(!x)`         
            `XCTAssertNil(x)`       | `#expect(x == nil)`            
            `XCTAssertNotNil(x)` | `#expect(x != nil)`
            `XCTAssertEqual(x, y)` | `#expect(x == y)`
            `XCTAssertNotEqual(x, y)` | `#expect(x != y)`
            `XCTAssertIdentical(x, y)` | `#expect(x === y)`
            `XCTAssertNotIdentical(x, y)` | `#expect(x !== y)`
            `XCTAssertGreaterThan(x, y)` | `#expect(x > y))`
            `XCTAssertGreaterThanOrEqual(x, y)` | `#expect(x >= y)`
            `XCTAssertLessThanOrEqual(x, y)` | `#expect(x <= y)`
            `XCTAssertLessThan(x, y)` | `#expect(x < y)`
            `XCTAssertThrowsError(try f())` | `#expect(throws: (any Error).self) { try f() }`
            `XCTAssertThrowsError(try f()) { error in … }` | `#expect { try f() } throws: { error in return … }`
            `XCTAssertNoThrow(try f())` | `#expect(throws: Never.self) { try f() }`
            `try XCTUnwrap(x)` | `try #require(x)`
            `XCTFail("…")` | `Issue.record("…")`
            
        }
        
        @Steps {
            
            The overall goal will be to migrate from a test class written with XCTest to Swift Testing either on the Swift Island or on your own project.
            But first let's review some steps.
            
            @Step {
                It starts with the module import to replace.
                
                @Code(name: "AddDataModelTests", file: 40-migrate-import.swift)
            }
            
            @Step {
                Converting test classes.
                
                @Code(name: "AddDataModelTests", file: 41-migrate-convert-test-classes.swift)
            }
            
            @Step {
                In XCTest, code can be scheduled to run before and after a test using the setUp() and tearDown() family of functions. When writing tests using the testing library, implement init() and/or deinit instead
                
                @Code(name: "SwiftIslandTests", file: 42-migrate-setup-tearDown.swift)
            }
            
            @Step {
                The use of async and throws is optional. If teardown is needed, declare your test suite as a class or as an actor rather than as a structure and implement deinit
                
                @Code(name: "SwiftIslandTests", file: 43-migrate-using-async.swift)
            }
            
            @Step {
                The testing library represents individual tests as functions, similar to how they are represented in XCTest. However, the syntax for declaring a test function is different. In XCTest, a test method must be a member of a test class and its name must start with test. The testing library doesn’t require a test function to have any particular name. Instead, it identifies a test function by the presence of the @Test attribute
                
                @Code(name: "SwiftIslandTests", file: 44-migrate-convert-test-methods.swift)
            }
            
            @Step {
                Checking for expected values and outcomes: `XCTest` uses a family of approximately 40 functions to assert test requirements. These functions are collectively referred to as `XCTAssert()`. The testing library has two replacements, `expect(_:_:sourceLocation:)` and `require(_:_:sourceLocation:)`. They both behave similarly to `XCTAssert()` except that `require(_:_:sourceLocation:) throws an error if its condition isn’t me
                
                @Code(name: "SwiftIslandTests", file: 45-migrate-check-expected-values.swift)

            }
            
            @Step {
                Check for optional values. `XCTest` also has a function, XCTUnwrap(), that tests if an optional value is nil and throws an error if it is. When using the testing library, you can use require(_:_:sourceLocation:) with optional expressions to unwrap them
                
                @Code(name: "SwiftIslandTests", file: 46-migrate-check-optional-values.swift)

            }
            
            @Step {
                Record issues. Finally, `XCTest` has a function, `XCTFail()`, that causes a test to fail immediately and unconditionally. This function is useful when the syntax of the language prevents the use of an `XCTAssert()` function. To record an unconditional issue using the testing library, use the `record(_:sourceLocation:)` function:
                
                @Code(name: "SwiftIslandTests", file: 47-migrate-record-issues.swift)

            }
            
            @Step {
                An instance of an `XCTestCase` subclass can set its continueAfterFailure property to false to cause a test to stop running after a failure occurs. `XCTest` stops an affected test by throwing an Objective-C exception at the time the failure occurs.
                
                @Code(name: "SwiftIslandTests", file: 48-migrate-continue-halt-after-failures.swift)
                
                @Comment {
                    The testing library doesn’t use exceptions to stop test functions. Instead, use the require(_:_:sourceLocation:) macro, which throws a Swift error on failure:
                }
            }
            
            @Step {
                Validate asynchronous behaviors: 
                
                @Code(name: "SwiftIslandTests", file: 49-migrate-validate-async-behaviour.swift)
                
                @Comment {
                    XCTest has a class, XCTestExpectation, that represents some asynchronous condition. You create an instance of this class (or a subclass like XCTKeyPathExpectation) using an initializer or a convenience method on XCTestCase. When the condition represented by an expectation occurs, the developer fulfills the expectation. Concurrently, the developer waits for the expectation to be fulfilled using an instance of XCTWaiter or using a convenience method on XCTestCase.
                    Wherever possible, prefer to use Swift concurrency to validate asynchronous conditions. For example, if it’s necessary to determine the result of an asynchronous Swift function, it can be awaited with await. For a function that takes a completion handler but which doesn’t use await, a Swift continuation can be used to convert the call into an async-compatible one.
                    Some tests, especially those that test asynchronously-delivered events, cannot be readily converted to use Swift concurrency. The testing library offers functionality called confirmations which can be used to implement these tests. Instances of Confirmation are created and used within the scope of the function confirmation(_:expectedCount:sourceLocation:_:).
                    Confirmations function similarly to the expectations API of XCTest, however, they don’t block or suspend the caller while waiting for a condition to be fulfilled. Instead, the requirement is expected to be confirmed (the equivalent of fulfilling an expectation) before confirmation() returns, and records an issue otherwise:
                }
            }
            
            @Step {
                Control whether a test runs: When using `XCTest`, the `XCTSkip` error type can be thrown to bypass the remainder of a test function. As well, the `XCTSkipIf()` and `XCTSkipUnless()` functions can be used to conditionalize the same action. The testing library allows developers to skip a test function or an entire test suite before it starts running using the ConditionTrait trait type. Annotate a test suite or test function with an instance of this trait type to control whether it runs
                
                @Code(name: "SwiftIslandTests", file: 50-migrate-control-when-test-run.swift)
            }
            
            @Step {
                Annotate known issues. A test may have a known issue that sometimes or always prevents it from passing. When written using `XCTest`, such tests can call `XCTExpectFailure(_:options:failingBlock:)` to tell `XCTest` and its infrastructure that the issue shouldn’t cause the test to fail. The testing library has an equivalent function with synchronous and asynchronous variants:
                
                @Code(name: "SwiftIslandTests", file: 51-migrate-annotate-known-issues.swift)
                
                @Comment {
                    Note
                    The XCTest function XCTExpectFailure(_:options:), which doesn’t take a closure and which affects the remainder of the test, doesn’t have a direct equivalent in the testing library. To mark an entire test as having a known issue, wrap its body in a call to withKnownIssue().
                }
            }
            
            @Step {
                If a test may fail intermittently, the call to XCTExpectFailure(_:options:failingBlock:) can be marked non-strict. When using the testing library, specify that the known issue is intermittent instead:
                
                @Code(name: "SwiftIslandTests", file: 52-migrate-test-failure.swift)
                
            }
            
            @Step {
                TODO: Migrate one of your projet or package test classes and try to fit as many examples as possible.
            }
        }
    }
}
